%Аналитическое решение
\section{Аналитическое решение}

Определитель матрицы $A$ равен $\omega_1^2 \omega_2^2 \omega_3^2$, что позволяет нам найти точное решение при помощи спектрального разложения.

\begin{equation}
	A=
	\begin{bmatrix}
		0 & 0 & 0 & 1 & 0 & 0 \\
		0 & 0 & 0 & 0 & 1 & 0 \\
		0 & 0 & 0 & 0 & 0 & 1 \\
		-\omega_1^2 - \omega_{21}^2 & \omega_{21}^2 & 0 & 0 & 0 & 0 \\
		\omega_2^2 & -\omega_{2}^2 - \omega_{32}^2 & \omega_{32}^2 & 0 & 0 & 0 \\
		0 & \omega_{3}^2 & -\omega_{3}^2 & 0 & 0 & 0 \\
	\end{bmatrix}	
\end{equation}

	Спектральное разложение имеет вид:
\begin{equation}
A = P^{-1} \Lambda P
\end{equation}
, где $A$ - изначальная матрица, $P$ - матрица собственных векторов, $\Lambda$- диагональная матрица, на диагонали которой расположены собственные числа матрицы $A$.
	Для данной задачи система ОДУ имеет вид: 
\begin{equation}
	\frac{d}{dt}q = A q
\end{equation}
	Применив спектральное разложения к матрице $A$, получим:
\begin{align}
	&\frac{d}{dt}q =  P^{-1} \Lambda P q,\\ 
	&\frac{d}{dt} P q =  \Lambda P q
\end{align}
	Произведем замену переменных $\tilde{q} = P q$. Теперь уравнение имеет вид:
\begin{equation}
	\frac{d}{dt}\tilde{q} = \Lambda \tilde{q}
\end{equation}
	Отсюда вектор $\tilde{q}$:
\begin{equation}\label{eq:q}
\tilde{q} = 
\begin{bmatrix}
 e^{\lambda_1 t} & & \\
    & \ddots & \\
    & & e^{\lambda_n t}
\end{bmatrix} \tilde{q}(0) ,
\end{equation}	
 где $t$ - время. В результате обратной замены получим $q = P^{-1} \tilde{q}$.

 Таким образом решение системы ОДУ сводится к нахождению собственных чисел матрицы $A$. Собственные числа можно найти аналитически, для этого запишем характеристический полином матрицы $A$:

\begin{multline}
	\lambda^6 + \lambda^4 ( \omega_{1}^2 + \omega_{2}^2 + \omega_{21}^2 + \omega_{3}^2 + \omega_{32}^2 ) + \lambda^2 (\omega_{1}^2 \omega_{2}^2 + \omega_{21}^2 \omega_{3}^2 + \omega_{21}^2\omega_{32}^2 + \omega_{3}^2 \omega_{2}^2 + \omega_{3}^2 \omega_{1}^2 +
	\omega_{32}^2 \omega_{1}^2) \\ + \omega_1^2 \omega_2^2 \omega_3^2 = 0\\
\end{multline} 
 Можно легко увидеть, что данное выражение легко сводится к кубическому уравнению вида:
 \begin{equation}
 	k^3 + k^2 W_1 + k W_2 + W_3 = 0 
 \end{equation}
, где 
 \begin{align}
 	&k = \lambda^2\\
 	&W_1 = \omega_{1}^2 + \omega_{2}^2 + \omega_{21}^2 + \omega_{3}^2 + \omega_{32}^2 \\
 	&W_2 = \omega_{1}^2 \omega_{2}^2 + \omega_{21}^2 \omega_{3}^2 + \omega_{21}^2\omega_{32}^2 + \omega_{3}^2 \omega_{2}^2 + \omega_{3}^2 \omega_{1}^2 +
	\omega_{32}^2 \omega_{1}^2\\
	&W_3 =  \omega_1^2 \omega_2^2 \omega_3^2
 \end{align}

Решим данное уравнение при помощи тригонометрической формулы Виета для кубического уравнения:

\begin{align}
	&Q = \frac{W_1^2 - 3 W_2}{9}\\
	&R = \frac{2 W_1^3 - 9 W_1 W_2 + 27 W_3}{54}\\
	&S = Q^3 - R^2
\end{align}

Если $S>0$, то имеем три действительных корня, вычисляемых при помощи тригонометрических функций. При $S<0$, тригонометрические функции заменяются на гиперболические и пара корней является комплексными. При $S=0$ уравнение вырождено и имеет два корня.
Программная реализация решателя на языке Python, использующего тригонометрическую формулу Виета, представлена в листинге \ref{lst:viett}.

\newpage
\begin{lstlisting}[numbers=none, label=lst:viett,language=Python, caption=Программная реализация решателя кубического уравнения при помощи теоремы Виета]
def cbslv(a, b, c):
	Q = (a**2 - 3*b)/9
	R = (2*a**3 - 9*a*b+27*c)/54
	S = Q**3 - R**2
	if S > 0:
		phi = cmt.acos(R/cmt.sqrt(Q**3))/3
		x1 = -2*cmt.sqrt(Q)* cmt.cos(phi) - a/3
		x2 = -2*cmt.sqrt(Q+2*np.pi/3)* cmt.cos(phi) - a/3
		x3 = -2*cmt.sqrt(Q-2*np.pi/3)* cmt.cos(phi) - a/3
	elif S < 0:
		if Q > 0:
			phi = cmt.acosh(abs(R)/cmt.sqrt(Q**3))/3
			x1 = -2*np.sign(R)*cmt.sqrt(Q)*cmt.cosh(phi) - a/3 # real root
			x2 = np.sign(R)*cmt.sqrt(Q)*cmt.cosh(phi) - a/3 + 1j*cmt.sqrt(3)*cmt.sqrt(Q)*cmt.sinh(phi)
			x3 = np.sign(R)*cmt.sqrt(Q)*cmt.cosh(phi) - a/3 - 1j*cmt.sqrt(3)*cmt.sqrt(Q)*cmt.sinh(phi)
		elif Q < 0:
			phi = cmt.asinh(abs(R)/cmt.sqrt(abs(Q)**3))/3
			x1 = -2*np.sign(R)*cmt.sqrt(abs(Q))*cmt.sinh(phi) - a/3 # real root
			x2 = np.sign(R)*cmt.sqrt(abs(Q))*cmt.sinh(phi) - a/3 + 1j*cmt.sqrt(3)*cmt.sqrt(abs(Q))*cmt.cosh(phi)
			x3 = np.sign(R)*cmt.sqrt(abs(Q))*cmt.sinh(phi) - a/3 - 1j*cmt.sqrt(3)*cmt.sqrt(abs(Q))*cmt.cosh(phi)
		elif Q == 0:
			x1 = -np.cbrt(c-(a**3)/27) - a/3
			x2 = -(a+x1)/2 +1j/2*cmt.sqrt(abs((a - 3*x1)*(a+x1)-4*b))
			x2 = -(a+x1)/2 -1j/2*cmt.sqrt(abs((a - 3*x1)*(a+x1)-4*b))
	elif S==0:
		x1 = -2*np.cbrt(R)-a/3
		x2 = np.cbrt(R)-a/3
		x3 = None
	return x1, x2, x3
\end{lstlisting}

Изначальной идеей нахождения аналитического решения было избавление от переменных и от большого количества арифметических операций. Это могло позволить найти прямые зависимости состояний системы от каких либо из ее параметров. Но в ходе подстановки не удалось сократить какие либо переменные, а вкупе с использованием ресурсозатратных гиперболических функций и вычислением сложных степеней больших чисел аналитическое решение приводит к ошибкам вычислений и отклонениям. А так же к большему времени расчетов, относительно численных методов.
